'''Modulis, kuriame aprasytas metodas surenkantis komanda ir jos argumentus, priklausomai,
nuo komandos tipo ir jos patterno apibrezto texsyntax modulyje.

Naudojimas: collect_full_command(pozicija,stringas)
pozicija -- komandos pradzia reiskianti metacharas "\\"
stringas -- parsinamo failo turinys

Return: (charu_skaicius,komanda,argumentu listas, originalus_tekstas)'''

import string, sys, os

try:
    if __IPYTHON__:
        if sys.platform=='win32':
            os.chdir('d:/Luko/vtexparser/')       
        else:
            sys.path.append('/home/lukas/vtexparser/')
except:
    pass

# LaTeX'o sintakse apibrezta 
# kitame modulyje
import latexsyntax

              ######################################## 
              #### PARSINIMO ERRORU APIBREZIMAI   ####
              ## tam, kad butu galima loginti visus ##
              ## netikusius parsinimo meginimus     ##
              
class ParseError(Exception):
    '''Motininis parsinimo Erroras'''
    def __init__(self,Msg,Poz):
        self.msg=Msg
        self.poz=Poz
    def __str__(self):
        return self.msg

class MatchError(ParseError):
    '''Erroras atsirandanti, kai 
    ieskoma nesuporuoto skirtuko.'''
    def __init__(self,Msg,Poz):
        super().__init__(Msg,Poz)

class EOSError(ParseError):
    '''Erroras atsirandanti, kai 
    ieskoma ten kur baigesi stringas.'''
    def __init__(self,Msg,Poz):
        super().__init__(Msg,Poz)
       
class AlgError(ParseError):
    '''Erroras atsirandantis 
    del blogai parasyto algoritmo.'''
    def __init__(self,Msg,Poz):
        super().__init__(Msg,Poz)

def context(poz,String,End=False,Range=50,Tag=False,Delim=False):
    '''Grazina eilutes konteksta apie esama
    symboli (symboliu seka).'''
    if Delim:
        delim=Delim
    else:
        delim=''
    if Tag:
        ltag=delim+'<'+Tag+'@-->'+delim
        rtag=delim+'<--@'+Tag+'>'+delim
    else:
        delim=''
        ltag=delim+'@-->>'
        rtag='<<@--'+delim
    if not End:
        
        End=poz
    else: End=End-1
    if poz<=Range: before=poz
    else: before=Range
        
    if len(String)-End<=Range: after=len(String)-End
    else: after=Range
    if Tag:
        return (ltag+String[poz:End+1]+rtag)
    else:
        if poz==0:
            return (ltag+String[poz:End+1]+rtag+String[End+1:End+after])
        else:
            return (String[poz-before:poz]+ltag+String[poz:End+1]+rtag\
                    +String[End+1:End+after])

              ######################################## 
              ####         PARSINIMO METU         ####
              ##     INICIALIZUOJAMI OBJEKTAI       ##

class ParseObject():
    '''Universalus objektas parsinime.'''
    def __init__(self,tipas):
        self.body=''                      # skriptinio pavidalo kunas
        self.Type=tipas

class FruitfullObject(ParseObject):
    '''Objektas turinti vidine struktura,
    sudaryta is kitu objektu.'''
    def __init__(self,tipas):
        super().__init__(tipas)
        self.kids=[]

              ######################################## 
              ####      OBJEKTU KOMPONENTAI       ####

class Opening:
    '''Skirtukai atidanatys reiskini'''
    def __init__(self,Tipas,Name,Body):
        self.Type=Tipas
        self.name=Name
        self.body=Body

class Closing(Opening):
    def __init__(self,Tipas,Name,Body):
        super().__init__(Tipas,Name,Body)

              ######################################## 
              ####   IPRASTI METODAI NAUDOJAMI    ####
              ##         PARSINIMO PROCESE          ##
                    
def escaped(poz,String,syntax='T'):
    '''Patikriname ar esamas charas 
    nera escapintas.
    Parasyta, numatant escape charo
    sintakses pasikeitimo galimybe.'''
    # DEBUGING :: jei syntakseje neapibreztas escape charas
    try:
        ESC_CH=latexsyntax.SYNTAX[syntax]['escape']
    except KeyError:
        return False
    # :::
    if poz==0: return False
    if not (String[poz-1] in ESC_CH.keys()):
        return False
    # DEBUGING :: PATIKRINAME AR NEBUVO SINTAKSES KEITIMO
    elif ESC_CH[String[poz-1]]:
        raise AlgError(
            "Pakeista escape charu sintakse "\
            "ir nenurodytas elgsenos tipas!!!:"\
            "\n{}\nEscape charu sarasas"\
            ":\n{}".format(context(poz-1,String),
                           ESC_CH),poz-1)    
    # :::
    else:
        # suskaiciuojam kiek yra 
        # vienas po kito einanciu backslashu
        # pries esama chara
        slashes=0
        i=poz-1
        while (String[i] in ESC_CH.keys()):
            slashes+=1
            if i==0: break
            i-=1
        if not slashes%2:return False
        else: return True

def metachar(poz,String,syntax='T'):
    '''Jei charas yra metacharu sarase, 
    tai patikrinam ar jis neeskeipintas.'''
    META_CH=latexsyntax.SYNTAX[syntax]['metach']
    keys=META_CH.keys()
    # print("\nmetacharai:",META_CH,'\nsymbolis:',String[poz])
    if not (String[poz] in keys):
        return False
    if poz==0:
        return True  
    if escaped(poz,String,syntax):
        return False
    else: return True

def metachar_greedy(poz,String):
    '''Jei esamas charas nera metacharas
    ismeta parsingo errora.
         
    Naudoti ten kur butinai reikalingas metachar'''
    if metachar(poz,String): return True
    else: 
        raise AlgError(
            'Sis simbolis nera metacharas:'\
            '\n{}'.format(context(poz,String)),poz)
            
def EOS(poz,String):
    '''Tikrinama ar esamas charas
    nera eilutes pabaiga.'''
    return poz>=len(String)-1
            
def skip_whitespace(poz,String,WHITES=latexsyntax.WHITESPACE):
    '''Praleidziam visus whitespace, kurie
    yra ne newline. 
    Grazinamas whitespacu sekos ilgis.'''
    # DEBUGING :::
    if (not (String[poz] in WHITES)) or escaped(poz,String):
        raise AlgError(
            'Tai nera whitespaceas:"\
            "\n{}'.format(context(poz,String)),poz)
    # ::: 
    i=poz
    while String[i] in WHITES:
        if EOS(i,String): 
            # paliekam viena whitespace
            # kitoms funkcijoms
            return i-poz
        i+=1
    return i-poz

              ######################################## 
              ####   INLINE KOMENTARU SURINKIMO   ####
              ##            MECHANIZMAS             ##

def is_start_of_comment(i,String,syntax):
    '''Patikriname ar esamas charas yra 
    inline komentaro pradzia. Jei taip grazina: 
    (chara kuris isjungs komentara, opciju rinkini).
    Opciju rinkinys yra reikalingas tam, nes galima
    perapibrezti komentara taip, kad sutikus isjungiamaji
    symboli, nebus surinkti sekantys whitespace.
    Taigi, raide 'w' nurodo, kad reikes surinkti whitespace.'''
    COMMENT=latexsyntax.SYNTAX[syntax]['icomment']
    if (String[i] in COMMENT.keys()) and metachar(i,String):
        return COMMENT[String[i]]
    else: return False
           
def skip_icomment(poz,String,syntax):
    '''Nuskaitomas komentaras ir grazinamas jo ilgis.
    Skaitoma tada, kai komentaro jungiklis yra metachar'''
    COMMENT=latexsyntax.SYNTAX[syntax]['icomment']
    if is_start_of_comment(poz,String,syntax):
        cstart=String[poz]
        cend=is_start_of_comment(poz,String,syntax)[0]
        cprop=is_start_of_comment(poz,String,syntax)[1]
    else:
        raise AlgError('Tai nera komentaro "\
          "jungiklis!:\n{}'.format(context(poz,String)),poz)
    MULTILINE=True
    i=poz
    while MULTILINE:
        while String[i]!=cend:
            # jei komentaras uzbaigtu faila
            if EOS(i,String):
                raise EOSError(
                    "Komentaras uzbaigia teksta.\n"\
                    "Tikriausiai buvo ieskoma komandos argumento."\
                    "Kitiems atvejams skip_comment naudoti, su try!!!\n"\
                    "{}".format(context(i,String)),i)
            i+=1
        i+=1
        if String[i]==cstart: continue
        # Jei isjungigklis surenka visus trailing whitespace
        elif ('w' in cprop) and  (String[i] in latexsyntax.WHITESPACE):
                i+=skip_whitespace(i,String)
                # jei paskutinis white charas buvo string pabaiga
                if EOS(i,String):
                    raise EOSError(
                    "Whitespace seka uzbaigia teksta.\n"\
                    "Tikriausiai buvo ieskoma komandos argumento."\
                    "Kitiems atvejams skip_comment naudoti, su try!!!"
                    "\n{}".format(context(i,String)),i)
                # SURENKAMA KOMENTARU SEKA 
                if String[i]==cstart: continue
                else:
                    return i-poz
        else: return i-poz

                ################################################# 
                ######    KELIONE IKI KOMANDOS ARGUMENTO ########
                #### Preliudija i komandu surinkimus         ####
                #### taciau pirma bus surenkami enviromentu  ####
                #### pavadinimai                             ####
                
def is_start_of_cmd(poz,String,syntax='T'):
    '''Patikrinama ar esamas charas yra komandos pradzia.'''
    START_OF_CMD=latexsyntax.SYNTAX[syntax]['cmd_start']
    COMMAND_CHARS=latexsyntax.SYNTAX[syntax]['cmd_chars']
    if not (String[poz] in START_OF_CMD.keys()):
        return False
    else:
        if metachar(poz,String): return True
        else: return False

def skip_command_name(poz,String,syntax='T'):
    '''Padavus esama aktyvu chara ir jo pozicija 
    grazinamas komandos pavadinimo ilgis.'''
    START_OF_CMD=latexsyntax.SYNTAX[syntax]['cmd_start']
    COMMAND_CHARS=latexsyntax.SYNTAX[syntax]['cmd_chars']
    # patikriname ar esamas charas yra komandos
    # pradzios metacharas
    char=String[poz]
    if not is_start_of_cmd(poz,String):
        raise AlgError("Tai nera komanda aktyvuojantis simbolis:"\
                       "\n{}".format(context(i,String)),poz)
                       
    if START_OF_CMD[char]:
        raise AlgError(
                      "Pakeista komandos aktyvavimo sintakse "\
                      "ir nenumatyta elgsena!!!:"\
                      "\n{}Komanda aktyvuojanciu charu sarasas"\
                      ":\n{}".format(context(poz,String),
                                      START_OF_CMD),poz)
    # Jei netycia parsinama eilute uzsibaigtu 
    # komanda aktyvuojanciu symboliu
    if EOS(poz,String):
        raise ParseError(
            'Parsinama eilute baigiasi ten kur turetu prasideti'\
            'komandos pradzia:\n{}'.format(context(poz,String)),poz)
    # jei komanda susideda is simbolio
    if not (String[poz+1] in COMMAND_CHARS-{'*'}):
        return 2
    i=poz+1
    while String[i] in COMMAND_CHARS:
        if EOS(i,String):
            # jei netycia komanda uzbaigtu parsinama stringa
            raise EOSError("Renkant komanda buvo pasiektas teksto  "\
                           "galas.\nPries parsinant gale "\
                           "idekite papildoma newline, arba naudokite"\
                           "try:\n".format(context(i,String),i))
        i+=1
    return i-poz

def is_strict_switch(poz,String,syntax='T'):
    '''Patikrina ar esamas reiskinys yra atidarantis 
    grieztas switchas. Jei taip grazina jo ilgi.'''
    switches=latexsyntax.SYNTAX[syntax]['switches'].keys()
    k=skip_command_name(poz,String,syntax)
    if String[poz:poz+k] in switches:
       return k
    else: return False

def skip_till_argument(poz,String,syntax='T'):
    '''Praleidzia visus, nereiksmingus
    charus iki sekancio argumento.
    Tarp komandos ir argumento galimi tik 
    iprastiniai komentarai % ir whitespacai.
    Taip pat, dar neprasidejus komentarui  
    yra galimas 1-as newline.'''
    BEGIN_OF_ARG=latexsyntax.SYNTAX[syntax]['arg_beg']
    i=poz
    if String[poz] in BEGIN_OF_ARG:
        return 0
    if String[i] in latexsyntax.WHITESPACE:
        i+=skip_whitespace(i,String)
    # po komandos su whitespace galimas tik vienas newline 
    if String[i]=='\n':
        i+=1
    while not (String[i] in BEGIN_OF_ARG):
        if is_start_of_comment(i,String,syntax):
            i+=skip_icomment(i,String,syntax)
        elif String[i] in latexsyntax.WHITESPACE:
            i+=skip_whitespace(i,String)
        else: raise AlgError(
                "Nenumatytas charas tarp argumentu:\n"\
                "{}".format(context(i,String)),i)
        if EOS(i,String):
            raise EOSError(
                "Parsinamas tekstas baigiasi "\
                "komanda, kuri turi tureti argumenta:"\
                "\n{}".format(context(i,String)),i)
    return i-poz

def is_start_of_env(poz,String,syntax='T'):
    '''Patikrinama ar esama komanda yra env
    pradza'''
    i=poz
    ENV_SWITCH=latexsyntax.SYNTAX[syntax]['env_switch']
    k=skip_command_name(i,String)
    if (String[i:i+k] in ENV_SWITCH.keys()):
        return True
    else:
        return False

def is_end_of_env(poz,String,syntax='T'):
    '''Patikrinama ar esama komanda yra env
    pabaiga'''
    i=poz
    ENV_SWITCH=latexsyntax.SYNTAX[syntax]['env_switch']
    k=skip_command_name(i,String)
    if (String[i:i+k] in ENV_SWITCH.values()):
        return True
    else:
        return False
       
def collect_enviroment_name(poz,String,syntax='T'):
    '''Surenkamas ir grazinamas enviromento 
    pavadinimas. Grazinama: 
      (ilgis nuo switch pabaigos iki arg pabaigos,
      env_pavadinimas).'''
    ENV_SWITCH=latexsyntax.SYNTAX[syntax]['env_switch']
    METABRACES=latexsyntax.SYNTAX[syntax]['mbraces']
    COMMENT=latexsyntax.SYNTAX[syntax]['icomment']
    if not is_start_of_cmd(poz,String):
        raise AlgError("Cia ne enviromento pradzia--"\
                       "net ne komandos pradzia\n"\
                       "{}".format(context(poz,String)),i)
    i=poz
    k=skip_command_name(i,String)
    if not ((String[i:i+k] in ENV_SWITCH.keys())\
        or (String[i:i+k] in ENV_SWITCH.values())):
        raise AlgError("Cia ne enviromento pradzia"\
                       "{}".format(context(poz,String)),i)
    i+=k
    k=skip_till_argument(i,String)
    if not (String[i+k] in METABRACES.keys()):
        raise AlgError(
            "Envromento pavadinimas turi "\
            "buti apskliausti metaskliaustais!!!\n"\
            "{}".format(context(i,String)),i)
    i+=k
    left=String[i]
    right=METABRACES[String[i]][0] 
    braces=[1,0]
    i+=1
    arg=''
    while braces[0]!=braces[1]:
        if String[i]==left: 
                braces[0]+=1; i+=1
                continue
        elif String[i]==right: 
            braces[1]+=1; i+=1
            continue
        elif is_start_of_comment(i,String,syntax):
             k=skip_comment(i,String,syntax)
             i+=k
             continue
        arg+=String[i]    
        i+=1
    return i-poz, arg

              ######################################## 
              ####  APLINKU UZSIDARYMO TIKRINIMO  ####
              ##            MECHANIZMAI             ##
              #    Aptikus, nauja aplinka, reikia    #
              # nustatyti, jos uzsidarymo mechanizma #
    
def check_matching_env(poz,String,syntax,opening):
    '''Tikrinama ar esamas reiskinys, yra 
    enviromento uzdarymas. Opening -- nurodomas 
    enviromento pavadinimas.'''
    if not is_start_of_cmd(poz,String,syntax):
        return False
    if is_end_of_env(poz,String,syntax):
        if collect_enviroment_name(poz,String,syntax)[1]!=opening:
            return False
        else: 
            return collect_enviroment_name(poz,String,syntax)[0]
    
def check_matching_switch(poz,String,syntax,switch):
    '''Tikrina ar esamas reiskinys yra griezto switcho 
    uzdarymas.'''
    METACH=latexsyntax.SYNTAX[syntax]['metach']
    closing=latexsyntax.SYNTAX[syntax]['switches'][switch]['closing']
    if not is_start_of_cmd(poz,String,syntax):
        return False
    else:
        k=skip_command_name(poz,String,syntax)
        if String[poz:poz+k]==closing:
            return k
        else: return False

def check_matching_delim(poz,String,syntax='T',opening='{'):
    '''Tikrina ar esmas charas yra uzdarantis esamo
    objekto parsinima vienazenklis skirtukas.'''
    # DEBUGINIMUI :: istrinti po to, kai bus pilnai pratestuotas
    openings=latexsyntax.SYNTAX[syntax]['delims'].keys()
    if not (opening in openings):
        raise AlgError("Syntakseje \'{}\' neapibreztas"\
                       "skirtukas \'{}\'!\n Kontextas:\n"\
                       "{}".format(syntax,opening,context(poz,String)),poz)

    # :::
    closing=latexsyntax.SYNTAX[syntax]['delims'][opening]['closing']
    if String[poz]!=closing:
        return False
    # Jei esamas charas atitinka uzdarancio symbolio apibrezima
    # dar patikrinamos, kitos butinos savybes
    properties=latexsyntax.SYNTAX[syntax]['delims'][opening]['properties']
    if properties:
        if 'meta' in properties:
            # PROBLEMA: \\end{verbatim} 
            #       antras \ nesiskaito eskeipintas
            #       ir ji reiktu traktuoti, kaip metachar
            if metachar(poz,String,syntax):
                return 1
            else:
                return False
    # DEBUGINIMUI ::
    if escaped(poz,String,syntax):
        raise AlgError("Sis charas turejo buti surinktas "\
                       "kaip komanda:\n{}".format(context(poz,String)),
                       poz)
    # :::
    return True

def check_if_multichar(poz,String,syntax):
    '''Kai kurie aktyvus symboliai, gali sudaryti
    kombinacijas, pakeiciancias ju prasme. Butina tai
    pagauti is anksto!
    pvz.: $-->$$.'''
    if EOS(poz,String):
        raise ParseError("Esamas aktyvus charas uzbaigia parsinama eilute:"\
                         "\n{}".format(context(poz,String)),poz)
    char=String[poz]
    MULTICHAR=latexsyntax.SYNTAX[syntax]['delims'][char]['multichar']
    if String[poz:poz+2] in MULTICHAR:
        return String[poz:poz+2]
    else: 
        return False
            
def check_matching_multichar_delim(poz,String,syntax,opening):
    '''Sutikus  skirtuka, ar komanda, kuris turi opcija 'rpt' 
    (si opcija, reiskia, jog galimas ilgesnis  reiskinys,
    turintis kirtinga prasme), tikrinama, ar tai nera tas
    ilgesnis reiskinys.
    Pvz: sutikus $, tikrinama ar ne $$'''
    MULTICHAR_DELIMS=latexsyntax.SYNTAX[syntax]['mch_delims']
    closing=MULTICHAR_DELIMS[opening]['closing']
    properties=MULTICHAR_DELIMS[opening]['properties']
    if properties:
        if 'meta' in properties:
            if not metachar(poz,String,syntax):
                return False
    if String[poz]!=closing[0]:
        return False
    else:
        if String[poz:poz+len(closing)]==closing:
            return len(closing)

def identify_opening(opening,syntax='T'):
    '''Parenka parsinamo reiskinio 
    uzdarymo mechanizma atpazystanti metoda.
    Grazina funkcija, kuria bus tikrinama.'''
    DELIMS=latexsyntax.SYNTAX[syntax]['delims']
    MCH_DELIMS=latexsyntax.SYNTAX[syntax]['mch_delims']
    SWITCHES=latexsyntax.SYNTAX[syntax]['switches']
    ENVIROMENTS=latexsyntax.SYNTAX[syntax]['enviroments']
    if opening in DELIMS.keys():
        return lambda poz, String:\
           check_matching_delim(poz,String,syntax,opening), 'delimeter'
    if opening in MCH_DELIMS.keys():
        return lambda poz, String:\
           check_matching_multichar_delim(poz,String,syntax,opening), 'multichar_delimeter'
    elif opening in ENVIROMENTS.keys():
        return lambda poz, String:\
           check_matching_env(poz,String,syntax,opening), 'enviroment'           
    elif opening in SWITCHES.keys():
        return lambda poz, String:\
           check_matching_switch(poz,String,syntax,opening), 'switch'
    else: 
        raise AlgError("Reiskinys, kurio uzdarymo ieskoma "\
             "yra neapibreztas."
             "\n{}".format(opening),0)
    
              ######################################## 
              ####  PAPRASTOS STRUKTUROS OBJEKTU  ####
              ##       SURINKIMO  MECHANIZMAI       ##
            
def skip_text(poz,String,syntax):
    '''Surenkamas visas tekstas, kuris
    nera aktyvuotas aktyviais simboliais.'''
    i=poz
    while not metachar(i,String,syntax):
        if EOS(i,String):
            break
        i+=1
    return i-poz

def parse_icomment(poz,String,syntax):
    "inicializuoja komentara"
    k=skip_icomment(poz,String,syntax)
    return k

              ######################################## 
              ####            KOMANDOS            ####
              ##       SURINKIMO  MECHANIZMAI       ##

class Argument(ParseObject):
    '''Argumento objektas, savyje talpinantis
    argumento reiskini be skirtuku.'''
    def __init__(self,syntax):
        self.body=''
        self.syntax=syntax

class FruitfullArgument(Argument):
    '''Argumentas turintis vidine struktura.'''
    def __init__(self,body,syntax):
        super.__init__(body,syntax)
        self.kids=[]

class Command(ParseObject):
    '''Komanda su argumentais.
    syntax--sintakse kurioje inicializuota komanda
    name--komandos scriptine reprezentacija'''
    def __init__(self,tipas,name,syntax,address):
        self.Type=tipas
        self.name=name
        self.syntax=syntax
        self.address=address
        self.args=[]
        
def collect_argument(poz,String,syntax,new_address,command):
    '''Surenka argumenta priklausomai nuo to, 
    koks jo tipas. Sis metodas pats atpazysta argumento tipa,
    istirdamas pirmaji argumento symboli.
    Grazina argumento objekta. 
    Argumentui sukuriamas atskiras adresas.'''
    print("Pradedamas surinkineti argumentas")
    print("Esamas charas",String[poz])
    # symboliai, kurie gali buti argumento pradzios
    arg_beg=latexsyntax.SYNTAX[syntax]['arg_beg']
    if not (String[poz] in arg_beg):
        raise ParseError("Cia turetu buti argumento pradzia, "\
                         "taciau symbolis neatitinka argumento"\
                         "pradzios apibrezimo:{}\n"\
                         "{}".format(arg_beg,context(poz,String)),poz)
    braces=latexsyntax.SYNTAX[syntax]['mbraces']
    if String[poz] in braces.keys():
        print("Sis argumentas turi vidine struktura")
        Object=parse_wraped(poz,String,syntax,String[poz],1,
                                new_address)
        return Object
    cmd_start=latexsyntax.SYNTAX[syntax]['cmd_start']
    if String[poz] in cmd_start.keys():
        print("Sis argumentas yra komandos tipo")
        k=skip_command_name(poz,String,syntax)
        Argumentas=Argument(syntax)
        Argumentas.body=String[poz:poz+k]
        Argumentas.address=new_address
        return Argumentas
    else:
        print("Sis argumentas yra tiesiog symbolis")
        Argumentas=Argument(syntax)
        Argumentas.body=String[poz]
        Argumentas.address=new_address
        return Argumentas

def skip_braced(poz,String,
                meta=True,
                verb=False,
                COMMENT_SYNTAX=latexsyntax.COMMENT,
                METACHARACTERS=latexsyntax.METACHARACTERS):
        '''Grazina apskliausto reiskinio ilgi.
        Jei meta=True, tai renka tik aktyvius skliaustus,
        jei ne tai ieskos esamo skliausto poros.

        Jei verb==True, tai is sintakses bus trumpam ismesti 
        komentaro charai ir tarp skliaustu esancius % traktuos 
        kaip simbolius.'''
        if len(COMMENT_SYNTAX)!=1:
            raise AlgError(
                "Komentaro sintakses apibrezime yra daugiau"\
                "negu vienas simbolis:\n"\
                "{}\n{}".format(COMMENT_SYNTAX,context(i,String)),i)           
        COMMENT_SYNTAX=latexsyntax.COMMENT
        if meta:
            DELIMETERS=latexsyntax.ARG_DELIMS
        else:
            DELIMETERS=latexsyntax.BRACES
        # jei apskliaustas reiskinys yra
        # verbatimine aplinka, ir procento zenklas nereiskia 
        # komentaro pradzios
        if verb:
            del COMMENT_SYNTAX['%']
        i=poz
        char=String[poz]
        if (char in latexsyntax.DELIMETERS.keys()) and metachar(poz,String):
            left=String[poz]
            right=latexsyntax.ARG_DELIMS[left]
        else:
            raise AlgError("Tai nera argumento skirtukas:"\
                           "\n{}".format(context(i,String)),i)
        if EOS(i,String):
            raise EOSError(
                "Tekstas baigiasi, ten kur "\
                "turetu buti skliaudziamas argumentas!".format(
                    context(i,String)),i)
        i+=1
        braces=[1,0]
        while not braces[0]==braces[1]:
            if String[i] in COMMENT_SYNTAX.keys() and metachar(i,String):
                try:
                    i+=skip_comment(i,String)
                except EOSError:
                    raise MatchError(
                        'Nerasta skliausto pora!:\n{}'.format(
                            context(poz,String)),poz)
            if (String[i] in (left+right)) and metachar(i,String):
                if String[i]==left: 
                    braces[0]+=1
                elif String[i]==right:
                    braces[1]+=1
            if braces[0]==braces[1]: break
            if  EOS(i,String):
                raise MatchError(
                    'Nerasta skliausto pora!:\n{}'.format(
                        context(poz,String)),poz)
            i+=1
        return i-poz+1
                  
def collect_command(poz,String,syntax,pattern,Type,father,address):
    '''Surenka komanda, su jos argumentais, jei komandos
    argumentas yra verb tipo tai netikriname, komentaru buvimo
    ir pasiimame iki uzdarancio skliausto.
    Grazinamas komandos tipo objektas!'''
    print("\n\nPradedu komandos surinkima")
    komanda=''
    elem=0
    args=[]
    i=poz
    ilg=skip_command_name(poz,String,syntax)
    Komandos_pav=String[i:i+ilg]
    i+=ilg
    print('Pradedu komandos su zinomu paternu surinkima')
    print("KOMANDA:",komanda)
    print("POZICIJA:", context(i,String))
    print("Patternas:",pattern)
    # susirenkam zvaigzdute
    # ji atsiskiria nuo komandos kaip ir argumentas
    if komanda[-1:]!='*':
        ilg=skip_till_argument(i,String)
        if String[i+ilg]=='*':
            Komandos_pav=Komandos_pav+'*'
            i+=ilg+1
            print("surinkau komanda su zvaigzdute\n"\
            "dabartine mano pozicija:{}".format(
                context(i,String)))
            print("KOMANDA_SU_ZV:",Komandos_pav)
        else:
            pass
    command=Command(Type,Komandos_pav,syntax,address)
    print("Pradedu rinkti argumentus:\n",context(i,String)) 
    print("Komandos_Paternas:",pattern)
    if not pattern:
        args=None
    else:
        print("Si komanda turi paterna!!!")
        print("ESAME:",context(i,String))
        for nr,k in enumerate(pattern):
            # jei argumentas pagrindinis
            if k.isupper() or k!=0:
                # jei argumento syntakse nenurodyta
                if k.isdigit():
                    inner_syntax=syntax
                else :
                    inner_syntax=k
                print("ieskom pagrindinio argumento:\n",
                      context(i,String))
                ilg=skip_till_argument(i,String,syntax)
                i+=ilg
                print("pagrindinio argumento pradzia:\n",
                      context(i,String))
                new_address=address.append(elem)
                elem+=1
                argument=collect_argument(i,String,inner_syntax,
                                          new_address,command)
                command.args.append(String[i:i+ilg])
                i+=ilg
            # jei argumentas opcionalus 
            else:
                print("Pradedamas surinkineti opcionalus argumentas")
                ilg=skip_till_argument(i,String)
                if String[i+ilg]=='[':
                    print("Rastas opcionalus argumentas")
                    print("opcionalus:",context(i,String))
                    i+=ilg
                    k=skip_braced(i,String,left='[',right=']')
                    new_address=address.append(elem)
                    elem+=1
                    argument=Argument(syntax)
                    argument.body=String[i:i+k]
                    argument.address=new_address
                    i+=k
                else:
                    args.append(None)
                    pass

    father.kids.append(command)
    return command, i
    
           ############################################### 
             ######       PARSINIMO PROCESAS      #####
                #################################### 
                    ############################ 

              ######################################## 
              ####  PARSINIMO METODAI IR JU TIPAI ####
              #   Kiekvienoje syntakseje, aktyvus    #
              #    symboliai siejasi su metodais,    #
              #   Kiekvienas metodas turi savo tipa, #
              # i kuri atsizvelgus iskvieciamas atit-#
              # kamas algoritmas ir sukuriamas ati-  #
              # tinkamas objektas                    #
              
METHODS={
    # metodus sarase yra irasyti triju tipu objektai
    # simple_strc -- do_the_right_thing aptikes toki
    #       objekta, panaudoja metoda tokiam objektui
    #       surinkti
    'icomment':{
        'parse_type':'simple_str',
        'type':'comment',
        'method':parse_icomment
        },
    # wraped_up -- objektai reikalaujantys gilesnio parsinimo
    # ir turintys vienokius ar kitokius skirtukus
    'mbraces':{
        'parse_type':'inner_parse',
        'opening':'{',
        'syntax':'O',   # O reiskia isorine sintakse
        'type':'braced'
        },
    'math':{
        'parse_type':'inner_parse',
        'syntax':'M',
        'opening':'multichar',
        'type':'math'
        },
    'switch':{
        'parse_type':'inner_parse'
        },
    'tcommand':{
        'parse_type':'command'},
    'mcommand':{
        'parse_type':'command'},
    # verbatimo aplinkose komandos surenkamos kaip tekstiniai
    # elementai
    'vcommand':{
        'parse_type':'vcommand'}}

def parse(String, syntax='T', checking=None, father=FruitfullObject('MAIN'), 
          address=[]):
    '''Parsinimo eiga:
    * Tikrinama ar neuzsibaige esamas reiskinys
      - pasibaigus grazinamas vidinio reiskinio ilgis ir 
      - uzdaramcio skirtuko ilgis
    * Tikrinama ar neprasidejo naujas gilesnis reiskinys
      - gilesnio reiskinio parsinimui iskvieciamas 
        papildomas algoritmas, nustatinejantis kokio 
        objekto parsinima pradeti (metodas do_the_right_thing)
      - viskas, kas nera esamo reiskinio uzbaigimo
        skirtukas, yra kitas reiskinys.
      - kito reiskinio turinys gali buti ir neparsinamas,
        o tiesiog surenkamas (icomment,text,symbol ir t.t.)
    Grazinamas suparsinto teksto ilgis.'''
    # jei esamas reiskinys yra gilesnis
    if checking:
        checkas=checking
    else:
        checkas=lambda x,y: False
    elem=0
    i=0
    while True:
        if EOS(i,String):
            father.fulltext=String
            print("PARSINIMO PABAIGA",address)
            return father
        try:
            if checkas(i,String):
                # grazinami objekto ir isjungiklio ilgiai
                return i, checkas(i,String)
            else:
                # kito objekto kurimui perduodamas esamas adresas
                k=do_the_right_thing(i,String,syntax,father,address,elem)
                elem+=1
                i+=k
        except EOSError:
            print("Pasibaige nebaigus")

def do_the_right_thing(poz,String,syntax,father,address,elem):
    '''Jei esamas charas yra metacharas,
    apibreztoje syntakseje, kreipiasi i kita
    algoritma, kuris priklausomai nuo esamo,
    konteksto ir metacharui priskirtos reiksmes 
    grazina parsinimo metoda, tipa.

    Inicializuojant nauja elementa turi buti perduodamas
    tevelio adresas, kad ji butu galima ijungti i jo vidine struktura'''
    print("TIRIAMAS CHARAS",'>>'+String[poz]+'<<')
    print("Isorinis addresas",address)
    print("Sis elementas isoriniame adrese yra",elem)
    new_address=address+[elem]
    print("Busimo elemento adresas",new_address)
    METACHARS=latexsyntax.SYNTAX[syntax]['metach']
    # jei esamas symbolis yra metacharas esamoje syntakseje
    if metachar(poz,String,syntax):
        char=String[poz]
        # istraukiamas metodo pavadinimas susijes su metacharu
        method=latexsyntax.SYNTAX[syntax]['metach'][char]
        print("Su charu sisijes metodas",method)
        # is metodo istraukiamas busimo objekto parsinimo tipas 
        parse_type=METHODS[method]['parse_type']
        ############################## 
        ### jei tai yra struktura, kurios turini reikes parsinti
        if parse_type=='inner_parse':
            opening=METHODS[method]['opening']
            # jei atidarantis reiskinys turi ir kitokiu kombinaciuju 
            if opening=='multichar':
                if check_if_multichar(poz,String,syntax):
                    delim=check_if_multichar(poz,String,syntax)
                else: 
                    delim=String[poz]
            else: delim=String[poz]
            # Nustatome syntakse
            inner_syntax=METHODS[method]['syntax']
            # jei vidine syntakse lygi isorinei
            if inner_syntax == 'O':
                inner_syntax=syntax
            # ISKVIEVIAMAS METODAS PARSINANTIS ISSKIRTA REISKINI,
            # PERDUODAMAS ISORINIO REISKINIO ADRESAS, 
            # ATIDARANCIO SKIRTUKO ILGIS
            # VIDINIO REISKINIO NUMATOMA SINTAKSE
            Object=parse_wraped(poz,String,inner_syntax,delim,len(delim),
                                new_address)
            father.kids.append(Object)
            return Object.lenght
        # jei esamas metacharas reiskia komandos pradzia 
        elif parse_type=='command':
            # jei esama komanda yra grieztas switchas
            if is_strict_switch(poz,String,syntax):
                k=is_strict_switch(poz,String,syntax)
                switch=String[poz:poz+k]
                inner_syntax=latexsyntax.SYNTAX[syntax]['switches']\
                  [switch]['content']
                if inner_syntax == 'O':
                    inner_syntax=syntax
                Object=parse_wraped(poz,String,inner_syntax,switch,
                                    len(switch),new_address)
                father.kids.append(Object)
                return Object.lenght
            # jei esama komanda yra enviromento pradzia 
            elif is_start_of_env(poz,String,syntax):
                lenght, name=collect_enviroment_name(poz,String,syntax)
                opening=String[poz:poz+lenght]
                inner_syntax=latexsyntax.SYNTAX[syntax]['enviroments']\
                  [name]['content']
                if inner_syntax == 'O':
                    inner_syntax=syntax
                Object=parse_wraped(poz,String,inner_syntax,name,
                                    lenght,new_address)
                Object.opening.body='\\begin{'+name+'}'
                Object.closing.body='\\end{'+name+'}'
                father.kids.append(Object)
                return Object.lenght
            # jei tai nei enviromento nei switch tipo komanda
            else:
                k=skip_command_name(poz,String,syntax)
                commands=latexsyntax.SYNTAX[syntax]['commands']
                command=String[poz:poz+k]
                # jei tai zinoma komanda
                if command in commands.keys():
                    pattern=commands[command]['pattern']
                    Type=commands[command]['type']
                    Object,lenght=collect_command(poz,String,syntax,
                                                  pattern,Type,
                                                  father,new_address)
                    father.kids.append(Object)
                    return lenght
                # jei tai nezinoma komanda, surenkamas jos
                # skriptinis pavadinimas ir inicializuojama 
                # nezinoma komanda 
                else:
                    print("Rasta nezinoma komanda")
                    Object=Command('unknown',String[poz:poz+k],
                                   syntax,new_address)
                    Object.body=String[poz:poz+k]
                    print("Sios komandos kunas:",Object.body)
                    father.kids.append(Object)
                    return k
                
        elif parse_type=='vcommand':
            print("Radau komanda verbatimineje aplinkoje!")
            k=skip_command_name(poz,String,syntax)
            print("Jos ilgis",k)
            command=String[poz:poz+k]
            print("Komanda:",command)
            Object=ParseObject("text")
            Object.body=String[poz:poz+k]
            Object.lenght=k
            Object.address=new_address
            father.kids.append(Object)
            return k
        ##############################
        ### jei tai struktura, kurios turinys paprastai surenkamas
        elif parse_type=='simple_str':
            Method=METHODS[method]['method']
            Type=METHODS[method]['type']
            k=Method(poz,String,syntax)
            Object=ParseObject(Type)
            Object.body=String[poz:poz+k]
            Object.lenght=k
            Object.address=new_address
            print("SUKURTAS PAPRASTOS STRUKTUROS OBJEKTAS:",
                  '>>'+Object.body+'<<')
            father.kids.append(Object)
            return Object.lenght
    else:
        k=skip_text(poz,String,syntax)
        Object=ParseObject("text")
        Object.body=String[poz:poz+k]
        Object.lenght=k
        Object.address=new_address
        father.kids.append(Object)
        print("SUKURTAS TEKSTO OBJEKTAS:",'>>'+Object.body+'<<')
        return Object.lenght

def parse_wraped(poz,String,syntax,opening,len,address):
    '''Paduodamas atidarancio skirtuko pavadinimas ir 
    jo ilgis skriptiniame faile.
    
    Visi pavadinimai sutampa su skirtukais, iskytus
    enviromentus. Perduodant enviromenta uztenka paduoti 
    jo pavadinima be jokiu aktyviu charu ir nuskaityta 
    ilgi skriptiniame faile.
    Grazinamas objektas su visa vidine struktura!'''
    print("\nParsinu_apgaubta:",String[poz:])
    print("Atidarantis_reiskinys:",opening)
    print("Apgaubto elemento adresas",address)
    # Sukuriamas objektas, galintis tureti vaiku
    Object=FruitfullObject('wraped')
    # Patikrinama, kas per atidarantis reiskinys
    # gaunamas tikrinimo mechanizmas ir tipas
    check, Type = identify_opening(opening, syntax)
    print("Reiskinio tipas",Type)
    # Sukuriamas atidarancio reiskinio objektas
    # Ir pridedamas prie esamo objekto
    Object.opening=Opening(Type,opening,String[poz:poz+len])
    k, closing_len = parse(String[poz+len:],syntax,check,Object,address)
    print("Vidinio reiskinio ilgis:",k)
    print("Vidinis_reiskinys:",'>>'+String[poz+len:poz+len+k]+'<<')
    print("Uzdarantis reiskinys:",String[poz+len+k:poz+len+k+closing_len])
    print("Viso reiskinio ilgis:",len+k+closing_len)
    # print("apgaubtas_baigesi:",String[poz+k+closing_len:])
    Object.closing=Closing(Type,opening,String[poz+len+k:poz+len+k+closing_len])
    Object.lenght=len+k+closing_len
    Object.address=address
    Object.body=String[poz+len:poz+len+k]
    return Object


# test=''' { \\begin{equation}
#     \\[ apacia \\]  pries 
#     \\iffalse {sito \\[nereikia\\] $parsinti$ } \\fi 
#      po 
#      \\end
#      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#      {equation}  
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#      { $cia mtm$  { ir t.t  {   $ { kalno virsus  } $ }}}} $$ {a+b}{c+d} $$ $ x+y$ \\begin   
#     {equation}  aaa \\begin%    
#     {verbatim}   bbb \\end {verbatim}  aaaa  \\end{equation}   
#      '''

test="tebunie taip \\mbox{vidinis argumentas}    aaa"

objektas=parse(test,'T')

def prasuk_objekta(objektas):
    for i in objektas.kids:
        if type(i)==FruitfullObject:
            print('   '*len(i.address), i.opening.body)
            prasuk_objekta(i)
            print('   '*len(i.address), i.closing.body)
        else:
            print('   '*len(i.address),'['+i.tipas+':'+i.body+']')
    
# prasuk_objekta(objektas)

def skip_inline_verbatim(poz,String):
    '''Verbatimine aplinka neturi aktyviu charu
    vienintelis aktyvus charas yra verbatimo esamas
    skirtukas.'''
    i=poz
    k=skip_command_name(poz,String)
    if String[i:i+k]!='\\verb':
        raise AlgError(
            "Cia ne inline verbatimo pradzia:\n"\
            "{}".format(context(i,String)),i)
    i+=k
    sym=String[i]; i+=1
    while String[i]!=sym:
        i+=1
        if EOS(i,String):
            raise EOSError("Renkant inline verbatima buvo "\
                         "pasiektas teksto galas.:\n"\
                         "{}".format(context(poz,String),poz),poz)
    i+=1
    return i-poz
           
def find_match(poz,String,syntax='T'):
    '''IESKOMA SUPORUOTO REISKINIO, 
    ATITINKAMAI KVIECIANT SITA PACIA 
    FUNKCIJA PAIESKOS PROCESE!
    - verbatiminiai komandu argumentai
    - verbatiminiai enviromentai
    - verbatiminiai griezti switchai
    Apejimas atliekamas, naudojant taip pat sita 
    funkcija.'''
    # PIRMA NUSTATOMA, KA APIEDINESIM
    # KREIPIANTI I FUNKCIJA NURODOMA VIDUJE 
    # SUPORUOTU REISKINIU ESANTI SYNTAKSE
    METACHARS=latexsyntax.SYNTAX[syntax]['metach']
    pass
    



            
def find_matching(poz,String,syntax='T'):
    '''Suranda suporuota reiskini,
    supranta ar ieskoti:
    - metaskliaustu
    - ar griezto switch
    - ar enviromento.
    Ieskodamas apeina inline komentarus,
    inline verbatimus ir kitas komentarines ir 
    verbatimines aplinkas.'''
    # NUSTATYMAS KO IESKOSIM IR KAS BUS ATIDARANTYS
    # IR UZDARANTYS REISKINIAI
    

            

        
# def is_verbatim(poz,String,VERB=latexsyntax.VERB):
#     '''Patikrina ar esama komanda yra
#     verbatimines aplinkos pradzia.
#     Grazina: 
#     i-jei inline verbatimas
#     e-jei enviromentas
#     s-jei grieztas switchas'''
#     if not is_start_of_cmd(poz,String):
#         return False
#     k=skip_command_name(poz,String)
#     if String[poz:poz+k] in VERB.keys():
#         return VERB[String[poz:poz+k]]
#     else: return False
    


        
def skip_braced_verb(poz,String,left='{',right='}'):
        '''Grazina apskliausto reiskinio ilgi.
        Reiskinyje netikrinamas komentaru buvimas'''        
        i=poz
        if left=='{':
            if EOS(i,String):
                raise EOSError(
                        "Tekstas baigiasi, ten kur "\
                        "turetu buti pagrindinis argumentas!".format(
                                context(i,String)),i)
        i+=1
        braces=[1,0]
        while not braces[0]==braces[1]:
            if (String[i] in (left+right)) and metachar(i,String):
                if String[i]== left: 
                    braces[0]+=1
                elif String[i]==right:
                    braces[1]+=1
            if braces[0]==braces[1]: break
            if  EOS(i,String):
                raise MatchError(
                    'Nerasta skliausto pora:\n{}'.format(
                        context(poz,String)),poz)
            i+=1
        return i-poz+1


def skip_argument(poz,String):
    '''Surenkamas komandos argumentas, priklausomai,
    nuo to koks dabartinis charas.'''
    i=poz
    if String[poz]=='\\':
        i+=skip_command(i,String)
    elif String[poz]=='{':
        i+=skip_braced(i,String)
    elif String[poz] in latexsyntax.ARGUMENT:
        i+=1
    else: 
        raise AlgError(
            "Turejo buti "\
            " pagrindinis argumentas:\n".format(context(i,String)),i)
    return i-poz

def skip_argument_verb(poz,String):
    '''Surenkamas komandos argumentas,
    kurio turinys verbatiminis.'''
    i=poz
    if String[poz]=='\\':
        raise ParseEroor(
            "Esamas argumentas turetu buti apskliaustas"\
            "nes jo turinys verbatim tipo".format(
                context(i,String),i))
    elif String[poz]=='{':
        # NEBEIGNORUOJAM KOMENTARU ARGUMENTE 
        i+=skip_braced_verb(i,String)
    elif String[poz] in latexsyntax.ARGUMENT:
        raise ParseEroor(
            "Esamas argumentas turetu buti apskliaustas"\
            "nes jo turinys verbatim tipo".format(
                context(i,String),i))
    else: 
        raise AlgError(
            "Turejo buti "\
            " pagrindinis argumentas:\n".format(context(i,String)),i)
    return i-poz

    



################# PRISTATYMUI ##########
######################################## 

#################### METACHARU TIKRINIMAS ##########
# for fn in list_of_files:
#     with open(fn,'rt',encoding="ascii") as failas:
#         textas=failas.read()
#         for i,j in enumerate(textas):
#             if metachar(i,textas):
#                 print(context(i,textas))
#                 input()        

  
# # #############INLINE KOMENTARU TESTINIMAS
# test_dir=os.path.join(os.path.curdir,'test/')
# list_of_files=os.listdir(test_dir)
# list_of_files=[os.path.join(test_dir,a) for a in list_of_files]
# for fn in list_of_files:
#     if fn[-8:]!='test.tex': continue
#     with open(fn,'rt',encoding="ascii") as failas:
#         textas=failas.read()
#         i=0
#         try:
#             while True:
#                 if is_start_of_comment(i,textas):
#                     k=skip_comment(i,textas)
#                     print(context(i,textas,End=i+k,Tag='komentaras'))
#                     input()
#                     i+=k 
#                 i+=1
#         except IndexError:
#             print("DARBAS BAIGTAS")
#         except EOSError:
#             print("DARBAS BAIGTAS")

